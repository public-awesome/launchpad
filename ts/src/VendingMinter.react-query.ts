/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.16.5.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { UseQueryOptions, useQuery, useMutation, UseMutationOptions } from "@tanstack/react-query";
import { ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { Uint128, Timestamp, Uint64, ConfigResponse, Coin, ExecuteMsg, Decimal, InstantiateMsg, CreateMinterMsgForVendingMinterInitMsgExtension, CollectionParams, CollectionInfoForRoyaltyInfoResponse, RoyaltyInfoResponse, VendingMinterInitMsgExtension, MinterParamsForParamsExtension, ParamsExtension, MintCountResponse, MintPriceResponse, MintableNumTokensResponse, Addr, MinterConfigForConfigExtension, ConfigExtension, QueryMsg, StartTimeResponse } from "./VendingMinter.types";
import { VendingMinterQueryClient, VendingMinterClient } from "./VendingMinter.client";
export const vendingMinterQueryKeys = {
  contract: ([{
    contract: "vendingMinter"
  }] as const),
  address: (contractAddress: string | undefined) => ([{ ...vendingMinterQueryKeys.contract[0],
    address: contractAddress
  }] as const),
  config: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...vendingMinterQueryKeys.address(contractAddress)[0],
    method: "config",
    args
  }] as const),
  mintableNumTokens: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...vendingMinterQueryKeys.address(contractAddress)[0],
    method: "mintable_num_tokens",
    args
  }] as const),
  startTime: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...vendingMinterQueryKeys.address(contractAddress)[0],
    method: "start_time",
    args
  }] as const),
  mintPrice: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...vendingMinterQueryKeys.address(contractAddress)[0],
    method: "mint_price",
    args
  }] as const),
  mintCount: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...vendingMinterQueryKeys.address(contractAddress)[0],
    method: "mint_count",
    args
  }] as const),
  status: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...vendingMinterQueryKeys.address(contractAddress)[0],
    method: "status",
    args
  }] as const)
};
export interface VendingMinterReactQuery<TResponse, TData = TResponse> {
  client: VendingMinterQueryClient | undefined;
  options?: Omit<UseQueryOptions<TResponse, Error, TData>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
}
export interface VendingMinterStatusQuery<TData> extends VendingMinterReactQuery<StatusResponse, TData> {}
export function useVendingMinterStatusQuery<TData = StatusResponse>({
  client,
  options
}: VendingMinterStatusQuery<TData>) {
  return useQuery<StatusResponse, Error, TData>(vendingMinterQueryKeys.status(client?.contractAddress), () => client ? client.status() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface VendingMinterMintCountQuery<TData> extends VendingMinterReactQuery<MintCountResponse, TData> {
  args: {
    address: string;
  };
}
export function useVendingMinterMintCountQuery<TData = MintCountResponse>({
  client,
  args,
  options
}: VendingMinterMintCountQuery<TData>) {
  return useQuery<MintCountResponse, Error, TData>(vendingMinterQueryKeys.mintCount(client?.contractAddress, args), () => client ? client.mintCount({
    address: args.address
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface VendingMinterMintPriceQuery<TData> extends VendingMinterReactQuery<MintPriceResponse, TData> {}
export function useVendingMinterMintPriceQuery<TData = MintPriceResponse>({
  client,
  options
}: VendingMinterMintPriceQuery<TData>) {
  return useQuery<MintPriceResponse, Error, TData>(vendingMinterQueryKeys.mintPrice(client?.contractAddress), () => client ? client.mintPrice() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface VendingMinterStartTimeQuery<TData> extends VendingMinterReactQuery<StartTimeResponse, TData> {}
export function useVendingMinterStartTimeQuery<TData = StartTimeResponse>({
  client,
  options
}: VendingMinterStartTimeQuery<TData>) {
  return useQuery<StartTimeResponse, Error, TData>(vendingMinterQueryKeys.startTime(client?.contractAddress), () => client ? client.startTime() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface VendingMinterMintableNumTokensQuery<TData> extends VendingMinterReactQuery<MintableNumTokensResponse, TData> {}
export function useVendingMinterMintableNumTokensQuery<TData = MintableNumTokensResponse>({
  client,
  options
}: VendingMinterMintableNumTokensQuery<TData>) {
  return useQuery<MintableNumTokensResponse, Error, TData>(vendingMinterQueryKeys.mintableNumTokens(client?.contractAddress), () => client ? client.mintableNumTokens() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface VendingMinterConfigQuery<TData> extends VendingMinterReactQuery<ConfigResponse, TData> {}
export function useVendingMinterConfigQuery<TData = ConfigResponse>({
  client,
  options
}: VendingMinterConfigQuery<TData>) {
  return useQuery<ConfigResponse, Error, TData>(vendingMinterQueryKeys.config(client?.contractAddress), () => client ? client.config() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface VendingMinterBurnRemainingMutation {
  client: VendingMinterClient;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useVendingMinterBurnRemainingMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, VendingMinterBurnRemainingMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, VendingMinterBurnRemainingMutation>(({
    client,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.burnRemaining(fee, memo, funds), options);
}
export interface VendingMinterShuffleMutation {
  client: VendingMinterClient;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useVendingMinterShuffleMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, VendingMinterShuffleMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, VendingMinterShuffleMutation>(({
    client,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.shuffle(fee, memo, funds), options);
}
export interface VendingMinterMintForMutation {
  client: VendingMinterClient;
  msg: {
    recipient: string;
    tokenId: number;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useVendingMinterMintForMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, VendingMinterMintForMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, VendingMinterMintForMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.mintFor(msg, fee, memo, funds), options);
}
export interface VendingMinterMintToMutation {
  client: VendingMinterClient;
  msg: {
    recipient: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useVendingMinterMintToMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, VendingMinterMintToMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, VendingMinterMintToMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.mintTo(msg, fee, memo, funds), options);
}
export interface VendingMinterUpdatePerAddressLimitMutation {
  client: VendingMinterClient;
  msg: {
    perAddressLimit: number;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useVendingMinterUpdatePerAddressLimitMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, VendingMinterUpdatePerAddressLimitMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, VendingMinterUpdatePerAddressLimitMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.updatePerAddressLimit(msg, fee, memo, funds), options);
}
export interface VendingMinterUpdateTradingStartTimeMutation {
  client: VendingMinterClient;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useVendingMinterUpdateTradingStartTimeMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, VendingMinterUpdateTradingStartTimeMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, VendingMinterUpdateTradingStartTimeMutation>(({
    client,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.updateTradingStartTime(fee, memo, funds), options);
}
export interface VendingMinterUpdateStartTimeMutation {
  client: VendingMinterClient;
  msg: Timestamp;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useVendingMinterUpdateStartTimeMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, VendingMinterUpdateStartTimeMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, VendingMinterUpdateStartTimeMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.updateStartTime(msg, fee, memo, funds), options);
}
export interface VendingMinterUpdateMintPriceMutation {
  client: VendingMinterClient;
  msg: {
    price: number;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useVendingMinterUpdateMintPriceMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, VendingMinterUpdateMintPriceMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, VendingMinterUpdateMintPriceMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.updateMintPrice(msg, fee, memo, funds), options);
}
export interface VendingMinterPurgeMutation {
  client: VendingMinterClient;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useVendingMinterPurgeMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, VendingMinterPurgeMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, VendingMinterPurgeMutation>(({
    client,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.purge(fee, memo, funds), options);
}
export interface VendingMinterSetWhitelistMutation {
  client: VendingMinterClient;
  msg: {
    whitelist: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useVendingMinterSetWhitelistMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, VendingMinterSetWhitelistMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, VendingMinterSetWhitelistMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.setWhitelist(msg, fee, memo, funds), options);
}
export interface VendingMinterMintMutation {
  client: VendingMinterClient;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useVendingMinterMintMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, VendingMinterMintMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, VendingMinterMintMutation>(({
    client,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.mint(fee, memo, funds), options);
}